package org.xtext

import java.io.File
import java.io.FileWriter
import java.util.HashMap
import java.util.Random
import org.eclipse.emf.common.util.URI
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl
import org.xtext.videogen.AlternativeVideoSeq
import org.xtext.videogen.MandatoryVideoSeq
import org.xtext.videogen.OptionalVideoSeq
import org.xtext.videogen.VideoGenModel

/**
 * Sert classe sert à générer une playlist à l'aide de la Factory
 * Cette playlist sera compréhensible par VLC 
 */
class TransformVideogen {
	new(){}
	
	
 	def loadVideoGenerator(URI uri) {		
		new VideogenStandaloneSetup().createInjectorAndDoEMFRegistration()
		var res = new ResourceSetImpl().getResource(uri, true)
		res.contents.get(0) as VideoGenModel
	}

	
	def saveVideoGenerator(URI uri, VideoGenModel pollS) {
		var Resource rs = new ResourceSetImpl().createResource(uri) 
		rs.getContents.add(pollS)
		rs.save(new HashMap())
	}
	def VideoToText(URI uri, VideoGenModel videogen){
        var File file = new File(uri.toString);
        val FileWriter fw = new FileWriter(file, true);
        
		videogen.variante_videos.forEach[video | 
			if (video instanceof AlternativeVideoSeq) {
				println("alternative")
				var size = video.video.size;
				var index = new Random().nextInt(size)
				
				fw.write("file '"+video.video.get(index).chemin+"'\n")
			} else if(video instanceof MandatoryVideoSeq){
				println("mandatory")
				fw.write("file '"+video.video.chemin+"'\n")
				
			} else if(video instanceof OptionalVideoSeq) {
				var rand = new Random().nextInt(2)
				if(rand > 0){
					println("optional")
					fw.write("file '"+video.video.chemin+"'\n")
				}
			} else {
				println("erreur");
			}
		]
		
		fw.close();
	}
	
	def static void main(String[] args) {
		var tranformvideogen = new TransformVideogen	
		var videoGen = tranformvideogen.loadVideoGenerator(URI.createURI("/Users/matthieucolliaux/Documents/Work/IDM/runtime-EclipseXtext/videogen/Sample.mydsl"))	
		tranformvideogen.VideoToText(URI.createURI("/Users/matthieucolliaux/Documents/Work/IDM/listvideo.txt"), videoGen)
	}
	/**
	 * Permet de gérer la playlist à partir du model VideoGenModel
	 */
 //def modeltoplaylist(VideoGenModel videogen){
		// récupération de la factory généré par Ecore Modeling Framwork
	//	var PlaylistFactoryImpl playlistFactory = PlaylistFactoryImpl.init() as PlaylistFactoryImpl
        // La playlist qu'on retourne et qui sera créée
      //  val PlaylistImpl playlistimpl = playlistFactory.createPlaylist() as PlaylistImpl
       
  	//	videogen.variante_videos.forEach[video|
  	//		var Videodesc videodesc =  null
  			
  	//		var typevideo = getType(video);
  			
  			// déleguation du traitement à d'autres fonctions
  			// Le but est d'affecter videoDesc
  	/* 		switch typevideo {
  				case 1: gererMandatory(video as MandatoryVideoSeq)
  				case 2 : gererOptional(video as OptionalVideoSeq) 
  				case 3 : gererAlternative(video as AlternativeVideoSeq)
  				default : println("erreur")
  			}
  			// récupérer la description
  			
  			// Il faudra faire attention avec les video alternatives ici, qui seront peut être une suite de video
  			
  			if (videodesc != null) {
				var Object obj = new PlaylistFactoryImpl().createVideo()
				var playlist_video = obj as Video
				gererDesc(playlist_video, videodesc)
			//	playlistimpl.
				//playlistimpl.video.add(playlist_video as VideoImpl)
			
			}
  		]
  		playlistimpl
	}
        
        
    /**
	 * permet de déterminer le genre de VarianteVideo
	 * @return int : A si Mandatory, 2 si Optional, 3 si alternative, 4 erreur
	 */
	/*def private static getType(VarianteVideo video){
		if (video instanceof MandatoryVideoSeq ) {
			return 1;
		} else if(video instanceof OptionalVideoSeq ){
			return 2;
		} else if(video instanceof AlternativeVideoSeq ) {
			return 3;
		}else{
			return 4;
		}
	}
	
	/// Gestions séparée pour chaque vidéos
	
	/**
	 * @return videodesc
	 */
/* 	def private static gererMandatory(MandatoryVideoSeq video){
		return video.video;
	}
	/**
	 * @return videodesc ou null
	 */
	/*def private static gererOptional(OptionalVideoSeq video){
		// Un sur Deux 
		return gererOptionalProba(video);
	}
	/**
	 * @return videodesc ou null
	 */
/* 	def private static gererAlternative(AlternativeVideoSeq video){
		return gererAlternativeProba(video)
	}
	
	
	/// Gestion des probabilités
	/** 
	 * Permet de gerer la probabilité d'apparation des videos Optional
	 * @return null ou video
	 */
/* 	def private static gererOptionalProba(OptionalVideoSeq video){
		var rand = Math.random();
		if(rand >= 0.5){
			return video.video;
		}else {
			return null
		}
	}

	/** 
	  * Permet de gerer la probabilité d'apparation des videos Alternatives
	  *  @return null ou video
	 */
/* 	def private static gererAlternativeProba(AlternativeVideoSeq video){
		var size = video.video.size;
		var proba = 1 / 10;
		var listeVideoReturn = new LinkedList<Videodesc>
		var listvideo = video.video;
		// MODIFIER LE CORPS DE CETTE FUNCTION
				/*
		 * // pour chaque video on regarde si on les prends et si on les prends on ajoute dans la liste à retourner
		
		listvideo.forEach[videodesc | 
			var rand = Math.random();
			if(rand <= 0.1){
				listeVideoReturn.add(videodesc)
				
			}
		]
		
		return listerVideoReturn;
		* 
		*/
		//return null;
	//}
	
	//def private static gererDesc(Video playlistVideo, Videodesc videodesc){
		
//	}
  
}